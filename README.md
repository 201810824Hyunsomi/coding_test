# coding_test
coding_test algorithm 

## 3. greedy 알고리즘
   1. 최소한 동전개수로 거스름돈 주기: 큰단위부터 돈을 거슬러줘야함, 시간복잡도는 동전의 총 종류에 영향을 받음, //와 %연산자를 사용해 for문 더 간단하게 구상할 필요 있음 
   2. 큰 수의 법칙 : 최대 k번 더하고 두번쨰로 큰수를 더하는 것을 반복하면 되므로 반복되는 배열을 묶어 하나의 배열처럼 묶음으로 처리하는 코드를 연습해봄 
   3. 숫자 카드 게임
   4. 1이 될때까지 두과정 반복해서 수행하기 : 최대한 나누는 과정을 많이 넣으면 된다 !while 조건문으로 n이 k이상인 경우를 확인해주기 !!!!! 만약 나눈 후에도 1보다 크면 1 빼주는 경우도 생각하기 -> 제일 중요한 나누는 걸 먼저 많이 해준다는 생각으로 알고리즘 수정하기. 

## 4. 구현
   0.완전 탐색: 모든 경우의 수를 주저 없이 다 계산 하는 해결방법 / 시뮬레이션: 문제에서 제시한 알고리즘을 한단계씩 차례대로 직접 수행하는 방법
   1. 상하좌우 문제: 반복되는 코드를 move_types라는 변수를 선언해 for문으로 돌리는 방법 공부, 새로운 변수 선언하고 후에 if문을 넣어 무시하게 되는 경우는 기존변수에 새로운 변수를 대입하지 않고 continue처리해서 무시하기
   2. 시각: 3중 반복문으로 처리, 시각안에 특정 숫자 있는지 확인하려면 if '특정숫자' in str()+str() 
   3. 왕실의 나이트: ord() 특정한 한 문자를 아스키 코드값으로 변환하는 것 
   4. 게임 개발 : 일주일 후에 다시 도전.. 

## 5. dfs/bfs
   0. 탐색: 많은 양의 데이터중에 원하는 데이터를 찾는 과정(dfs,bfs) / 자료구조 스택(filo): 파이썬에서 스택을 이용할 땐 별도의 라이브러리는 필요없다. append()와 pop메서드를 사용하면  동일하게 작동한다. / 큐(fifo): collections모듈에서 제공하는 deque자료구조를 활용하면된다.(스택/큐장점을 모두 활용한 것) / 재귀함수(종료조건: if문): stack자료구조를 사용할때 쓰면 편리하고 대표적인 예로는 dfs가 있다. 
   1. dfs: 깊이 우선 탐색이라고 부르며 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.<구현방식> stack/ 재귀함수 
   2. 인접행렬: 2차원 배열로 그래프의 연결관계를 표현하는 방식/ 인접리스트: 리스트로 그래프의 연결관계를 표현하는 방식
   3. bfs: 너비 우선 탐색으로 가까운 노드부터 탐색하는 알고리즘이다. <구현방식> queue/큐 자료구조 이용
   4. 음료수 얼려먹기 문제: 방문한 지점마다 다시 상하좌우를 살펴보며 진행해야 하므로 재귀함수식의 진행과 스택을 사용하는 dfs가 적절함
   5. 미로 탈출 문제<도전>: 탈출하기 위한 최소 경로를 알아야 하므로 시작지점부터 가까운 노드부터 차례로 하나씩 모든 노드를 탐색한다는 점에서 bfs가 적당하다. 

## 6. 정렬
   0. 정렬: 데이터를 특정 기준에 따라서 순서대로 나열하는 것
   1. 선택정렬: 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고 그다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복한다. O(N제곱)
   2. 삽입정렬: 데이터를 정렬할때 그앞까지의 데이터는 이미 정렬되어있다고 가정하여 정렬된 데이터 리스트 중 적절한 위치를 찾은 뒤에 그 위치에 삽입한다. O(N)
   3. 퀵정렬: 기준을 설정하고 큰수와 작은 수를 교환한 후 리스트를 반으로 나누는 바익으로 동작한다. O(NLOGN)
   4. 계수정렬: 특정한 조건이 부합할때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다. 예를 들어 0이상100이하인 성적데이터를 정렬할때 계수정렬이 효과적이다. 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는 특징이 있다. 
   5. 파이썬의 정렬 라이브러리 sorted()함수, / 리스트 객체 내장함수 sort()
