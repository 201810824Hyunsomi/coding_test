# coding_test
coding_test algorithm 

## 3. greedy 알고리즘
   1. 최소한 동전개수로 거스름돈 주기: 큰단위부터 돈을 거슬러줘야함, 시간복잡도는 동전의 총 종류에 영향을 받음, //와 %연산자를 사용해 for문 더 간단하게 구상할 필요 있음 
   2. 큰 수의 법칙 : 최대 k번 더하고 두번쨰로 큰수를 더하는 것을 반복하면 되므로 반복되는 배열을 묶어 하나의 배열처럼 묶음으로 처리하는 코드를 연습해봄 
   3. 숫자 카드 게임
   4. 1이 될때까지 두과정 반복해서 수행하기 : 최대한 나누는 과정을 많이 넣으면 된다 !while 조건문으로 n이 k이상인 경우를 확인해주기 !!!!! 만약 나눈 후에도 1보다 크면 1 빼주는 경우도 생각하기 -> 제일 중요한 나누는 걸 먼저 많이 해준다는 생각으로 알고리즘 수정하기. 

## 4. 구현
   0.완전 탐색: 모든 경우의 수를 주저 없이 다 계산 하는 해결방법 / 시뮬레이션: 문제에서 제시한 알고리즘을 한단계씩 차례대로 직접 수행하는 방법
   1. 상하좌우 문제: 반복되는 코드를 move_types라는 변수를 선언해 for문으로 돌리는 방법 공부, 새로운 변수 선언하고 후에 if문을 넣어 무시하게 되는 경우는 기존변수에 새로운 변수를 대입하지 않고 continue처리해서 무시하기
   2. 시각: 3중 반복문으로 처리, 시각안에 특정 숫자 있는지 확인하려면 if '특정숫자' in str()+str() 
   3. 왕실의 나이트: ord() 특정한 한 문자를 아스키 코드값으로 변환하는 것 
   4. 게임 개발 : 일주일 후에 다시 도전.. 

## 5. dfs/bfs
   0. 탐색: 많은 양의 데이터중에 원하는 데이터를 찾는 과정(dfs,bfs) / 자료구조 스택(filo): 파이썬에서 스택을 이용할 땐 별도의 라이브러리는 필요없다. append()와 pop메서드를 사용하면  동일하게 작동한다. / 큐(fifo): collections모듈에서 제공하는 deque자료구조를 활용하면된다.(스택/큐장점을 모두 활용한 것) / 재귀함수(종료조건: if문): stack자료구조를 사용할때 쓰면 편리하고 대표적인 예로는 dfs가 있다. 
   1. dfs: 깊이 우선 탐색이라고 부르며 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.<구현방식> stack/ 재귀함수 
   2. 인접행렬: 2차원 배열로 그래프의 연결관계를 표현하는 방식/ 인접리스트: 리스트로 그래프의 연결관계를 표현하는 방식
   3. bfs: 너비 우선 탐색으로 가까운 노드부터 탐색하는 알고리즘이다. <구현방식> queue/큐 자료구조 이용
   4. 음료수 얼려먹기 문제: 방문한 지점마다 다시 상하좌우를 살펴보며 진행해야 하므로 재귀함수식의 진행과 스택을 사용하는 dfs가 적절함
   5. 미로 탈출 문제<도전>: 탈출하기 위한 최소 경로를 알아야 하므로 시작지점부터 가까운 노드부터 차례로 하나씩 모든 노드를 탐색한다는 점에서 bfs가 적당하다. 

## 6. 정렬
   0. 정렬: 데이터를 특정 기준에 따라서 순서대로 나열하는 것
   1. 선택정렬: 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고 그다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복한다. O(N제곱)
   2. 삽입정렬: 데이터를 정렬할때 그앞까지의 데이터는 이미 정렬되어있다고 가정하여 정렬된 데이터 리스트 중 적절한 위치를 찾은 뒤에 그 위치에 삽입한다. O(N)
   3. 퀵정렬: 기준을 설정하고 큰수와 작은 수를 교환한 후 리스트를 반으로 나누는 바익으로 동작한다. O(NLOGN)
   4. 계수정렬: 특정한 조건이 부합할때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다. 예를 들어 0이상100이하인 성적데이터를 정렬할때 계수정렬이 효과적이다. 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는 특징이 있다. 
   5. 파이썬의 정렬 라이브러리 sorted()함수, / 리스트 객체 내장함수 sort()
   6. 배열의 원소 교체 문제: 배열하나는 오름차순으로 하나는 내림차순으로 정렬해 a에서 가장작은 원소를 b에서 가장 큰 원소와 교체를 하면 된다. 인덱스를 첫번째부터 차례대로 비교하여 a의 원소가 b의 원소보다 작을 때 교체를 수행한다. 

## 7. 정렬
   0. 순차탐색: 리스트 안에 특정한 데이터를 찾기 위해 앞에서부터 데이터를 차례대로 하나씩 확인하는 방법이다. 정렬되지 않은 리스트에서 데이터를 찾을 때 사용한다. 
   1. 이진탐색; 내부의 데이터가 정렬되어야 사용가능한 알고리즘으로 시작점 , 끝점, 중간점의 세개 변수가 필요하며 찾으려는 데이터와 중간점위치의 데이터를 반복적으로 비교하여 원하는 데이터를 찾는 방식이다.
   2. 이진탐색트리: 이진탐색이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조이다. 
   3. 빠르게 입력받기 : sys라이브러리를 사용하여 readline함수를 이용하면 입력데이터가 많은 문제를 잘 풀 수 있다. rstrip()함수를 꼭 호출해야한다. 
   4. 7_1 부품찾기 문제: 먼저 n개의 부품 번호로 정렬을 한 후에 확인 요청한 부품 번호를 리스트의 for문 반복으로 하나씩 확인하는 방법이 있다. 
   5. 7_2 떡볶이 떡 만들기 문제: 이진탐색 문제이자 파라매트릭 서치(최적화 문제를 결정 문제로 바꾸어 해결하는 방법) 문제이다. 원하는 조건을 만족하는 알맞은 값을 찾는 문제로 적절한 높이를 찾을때까지 h를 반복해서 조정하면 된다. 현재 높이로 자르면 만족하는가를 확인후 조건 만족 여부에 따라 탐색범위를 이진탐색으로 이용하여 절반씩 좁혀 나간다. 

## 8. 다이나믹 프로그래밍
   0. 메모리 공간을 사용하여 연산속도를 비약적으로 증가시킬 수 있는 방법으로 동일한 함수를 반복 호출하는 경우효율적으로 사용할 수 있다 . 
   1. 다이나믹 프로그래밍의 사용조건 -큰 문제를 작은 문제로 나눌 수 있다. - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다. 
   2. 메모이제이션: 다이나믹 프로그래밍을 구현하는 방법 중 하나로 한 번 구현한 결과를 메모리 공간에 메모해두고, 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미하고 메모이제이션은 값을 저장하는 방식이므로 캐싱이라고 한다. 
다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 떄는 이미 구한 정보를 그대로 리스트에서 가져오면 된다. 
보텀 업 방식(반복문을 이용하여 소스코드를 작성하는 경우 작은 문제를 차근차근 답을 도출한다고 함)은 상향식이라고 하며 결과 저장용 리스트는 dp테이블이라고 함다. 
   3. 1로 만들기 문제: 점화식을 세워서 소스코드를 작성하고 1을 빼는 연산을 제외하고는 해당 수로 나눠질때만 점화식을 적용할 수 있다. 
   4. 개미전사: i-1번째를 털 경우 현재 i케이스의 식량창고는 털지 못하고 i-2를 털 경우 현재 i케이스는 털 수 있다. 이 경우 max가 되는 값을 선택하면된다. 현재 i번째 식량창고에 있는 양이 ki라고 하면 ai=max(ai-1 , ai-2 + ki)
   5. 바닥공사: i-1까지 채워져 있으면 2x1크기 채우는 방법은 하나인데 i-2까지 채워져있으면 방법이 두가지가 존재한다. ai=ai-1+ai-2 x 2이렇게 점화식을 세워볼 수 있다. 
   6. 효율적인 화폐구성: 다시도전 !!!!!


### 8. 최단경로

   1. 
